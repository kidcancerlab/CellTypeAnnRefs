---
title: "Human Osteosarcoma Primary"
subtitle: "Cell type annotation reference assembly"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo=TRUE, 
  dev="svg", 
  fig.width=4, 
  fig.height=4,
  fig.asp=NULL
)

library(rrrSingleCellUtils)
library(Seurat)
library(ggplot2)
library(ggrepel)
library(tidyverse)
library(stringr)
library(harmony)
library(cowplot)
library(ggsci)
library(enrichR)
setEnrichrSite("Enrichr")

set.seed(888)

sysfonts::font_add("Arial Narrow", "ARIALN.TTF", bold = "ARIALNB.TTF")
showtext::showtext_auto()

theme_set(ggpubr::theme_pubr())

plot_cols <- c("#D43F3AFF", "#EEA236FF", "#357EBDFF", "#5CB85CFF", "#B8B8B8FF",
  "#9632B8FF",  "#46B8DAFF", "#90302DFF", "#A66D04FF", "#2D577FFF", "#3E7E3EFF",
  "#7D7D7DFF", "#6D1D87FF", "#097F9AFF", "#FF6E6AFF", "#FFBB70FF", "#68A4E3FF",
  "#79D379FF", "#CDCDCDFF", "#BF6BE2FF", "#69D1F3FF")

rDimPlot <- function(object, title, label = T, pt.size = 1, ...) {
  p <- Seurat::DimPlot(
    object = object, 
    label = label, 
    pt.size = pt.size,
    cols = alpha(plot_cols, 0.6),
    ...) +
    ggtitle(title) +
    theme(legend.position = "none") +
    coord_fixed()
  print(p)
  return(p)
}

rFeaturePlot <- function(object, features, title, pt.size = 1, order = T, ...) {
  p <- Seurat::FeaturePlot(
    object = object,
    features = features,
    pt.size = pt.size,
    order = order,
    cols = (c("lightgoldenrod", "darkred")),
    ...) +
    ggtitle(title) +
    coord_fixed()
  print(p)
  return(p)
}
```

# Load published data from GSE152048

If not already done, download the data sets from the GEO repository, extract
matrices, import into a Seurat object, perform initial QC and append relevant 
clinical data for each sample, as reported in the manuscript.

```{r}
# Make a list of sample names
geo1 <- tibble(
  s = c("BC5", "BC6", "BC10", "BC11", "BC16",
    "BC17", "BC20", "BC21", "BC22"),
  qc = c(18000, 25000, 25000, 30000, 70000,
    40000, 70000, 50000, 50000),
  path = c("Conventional", "Conventional", "Conventional",
    "Conventional", "Conventional", "Chondroblastic",
    "Chondroblastic", "Intraosseous", "Chondroblastic"),
  type = c("Primary", "Primary", "Lung Met", "Primary", "Primary",
          "Lung Met", "Primary", "Primary", "Primary")
)

# Check if primary tumor directory exists and create if it doesn't
if(!dir.exists("PrimaryTumor")) {
  tar_dir <- "PrimaryTumor"
  dir.create(tar_dir)
}

# Download, file, and extract the files from GEO
if(!dir.exists("PrimaryTumor/GSE152048")) {
  tar_dir <- "PrimaryTumor/GSE152048"
  dir.create(tar_dir)
  geo_pre <- "https://ftp.ncbi.nlm.nih.gov/geo/series/GSE152nnn/GSE152048/suppl/GSE152048_"
  for(s in geo1$s){
    gse_path <- str_c(geo_pre, s, ".matrix.tar.gz")
    tar_file <- str_c(tar_dir, "/", s, ".tar.gz ")
    download.file(gse_path, destfile = tar_file, method = "auto")
    untar(tar_file, exdir = tar_dir)
    file.remove(tar_file)
  }
}

# Create a vector of normalized Seurat objects for all GSE152048 samples
raw <- c()
p <- list()
for(s in geo1$s) {
  x <- tenx_load_qc(str_c("PrimaryTumor/GSE152048/",
                          s, "/"))
  x <- subset(x, subset = nCount_RNA < geo1$qc[geo1$s == s] & percent.mt <13)
  x$src <- s
  x$type <- geo1$type[geo1$s == s]
  x$path <- geo1$path[geo1$s == s]
  x$gse <- "GSE152048"
  raw[[s]] <- x %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData() %>%
    RunPCA(verbose = F) %>%
    FindNeighbors(dims = 1:20) %>%
    FindClusters(resolution = 0.3) %>%
    RunUMAP(dims = 1:20)
  p[[s]] <- rDimPlot(raw[[s]], str_c(s, " basic clustering"))
}
rm (x)
plot_grid(plotlist = p, ncol = 3)
```

# Load published data from GSE162454

Transition to data from this second manuscript and process similar to
what was done above to add these samples to the reference construct.

```{r}
# Make a list of sample names
geo2 <- tibble(
  s = c("OS_1", "OS_2", "OS_3", "OS_4", "OS_5", "OS_6"),
  qc = c(50000, 45000, 23000, 50000, 50000, 45000),
  pre = c("GSM4952363_", "GSM4952364_", "GSM4952365_", "GSM5155198_",
    "GSM5155199_", "GSM5155200_")
)

# If the raw data from GEO hasn't been downloaded, go get it
if(!dir.exists("PrimaryTumor/GSE162454")) {
  tar_dir <- "PrimaryTumor/GSE162454"
  dir.create(tar_dir)
  geo_pre <- "https://ftp.ncbi.nlm.nih.gov/geo/series/GSE162nnn/GSE162454/suppl/GSE162454_RAW.tar"
  tar_file <- str_c(tar_dir, "/", "GSE162454.tar.gz ")
  options(timeout = 300)
  download.file(geo_pre, destfile = tar_file, method = "auto")
  untar(tar_file, exdir = tar_dir)
  file.remove(tar_file)
  for(s in geo2$s) {
    bfile <- str_c(geo2$pre[geo2$s == s], s, "_barcodes.tsv.gz")
    ffile <- str_c(geo2$pre[geo2$s == s], s, "_features.tsv.gz")
    mfile <- str_c(geo2$pre[geo2$s == s], s, "_matrix.mtx.gz")
    samp_dir <- str_c(tar_dir, "/", s)
    dir.create(samp_dir)
    file.rename(str_c(tar_dir, "/", bfile),
      str_c(samp_dir, "/", "barcodes.tsv.gz"))
    file.rename(str_c(tar_dir, "/", ffile),
      str_c(samp_dir, "/", "features.tsv.gz"))
    file.rename(str_c(tar_dir, "/", mfile),
      str_c(samp_dir, "/", "matrix.mtx.gz"))
  }
}

# Create a vector that contains normalized Seurat objects for all GSE162454
#   samples
p <- list()
for(s in geo2$s) {
  x <- tenx_load_qc(str_c("PrimaryTumor/GSE162454/",
                          s, "/"))
  x <- subset(x, subset = nCount_RNA < geo2$qc[geo2$s == s] & percent.mt <18)
  x$src <- s
  x$type <- "Primary"
  x$path <- "Conventional"
  x$gse <- "GSE162454"
  raw[[s]] <- x %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData() %>%
    RunPCA(verbose = F) %>%
    FindNeighbors(dims = 1:20) %>%
    FindClusters(resolution = 0.3) %>%
    RunUMAP(dims = 1:20)
  p[[s]] <- rDimPlot(raw[[s]], str_c(s, " basic clustering"))
}
rm(x)
plot_grid(plotlist = p, ncol = 3)

```

# Subsample and merge Seurat objects

Subsample each patient sample so that we retain a representative number of cells from
each. Merge the samples into a single Seurat object and perform a batch correction/
integration procedure using harmony. 

```{r}
# Isolate samples obtained from primary tumors
prim <- c()
raw <- raw[!names(raw) %in% c("BC10", "BC17")]

# Downsample to retain equal numbers of cells across samples (equal representation)
for(s in names(raw)) {
  prim[[s]] <- subset(raw[[s]], cells = sample(Cells(raw[[s]]), 1000))
}

# Combine the downsampled datasets into a single seurat object and re-normalize
comb <- merge(prim[[1]], y = prim[2:length(prim)],
  add.cell.ids = names(raw),
  project = "PrimaryReference"
)

comb <- comb %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  ScaleData() %>%
  RunPCA(verbose = F)

# Run batch-correction/integration using harmony
comb <- RunHarmony(comb, group.by.vars = "src")
comb <- comb %>%
  RunUMAP(reduction = "harmony", dims = 1:30) %>%
  FindNeighbors(reduction = "harmony", dims = 1:30) %>%
  FindClusters()

# Save a stopping point - merged and harmony aligned
qs::qsave(comb, "PrimaryTumor/comb.qs")
```

```{r}
# Start from this stopping point - merged and harmony aligned
comb <- qs::qread("PrimaryTumor/comb.qs")

# Plot the integrated samples
rDimPlot(comb, "Primary Tumors (integrated)", repel = T)

rDimPlot(comb, "Primary Tumors (integrated)", group.by = "src")

rDimPlot(comb, "Primary Tumors (integrated)", split.by = "src", ncol = 4)
```

## Interim conclusions

A broad array of distinct cell types is represented across the different primary
tumor samples. These subsets appear to be of high enough quality and are appropriate
for building both an tumor cell and a stromal reference.

# A brief tangent - Optimize UMAP parameters

This code was created to illustrate how different changes in UMAP parameters affect
the way that cells cluster. Bottom line is that the default parameters work pretty
well and are fairly balanced, though tweaking can be helpful in certain situations.

```{r}
# p <- list()
# for(i in 1:5) {
#   test <- RunUMAP(comb, reduction = "harmony", dims = 1:30,
#     set.op.mix.ratio = (i-1)*0.25)
#   test <- test %>%
#     FindNeighbors(reduction = "harmony", dims = 1:30) %>%
#     FindClusters()
#   p[[i]] <- rDimPlot(test, reduction = "umap", label = T, repel = T) +
#       coord_fixed() +
#       ggtitle(str_c("set.op.mix.ratio = ", (i-1)*0.25)) +
#       theme(legend.position = "none")
# }
# plot_grid(plotlist = p, ncol = 3)

# p <- list()
# for(i in 1:5) {
#   test <- RunUMAP(comb, reduction = "harmony", dims = 1:30, 
#     n.neighbors = (i * 10))
#   test <- test %>%
#     FindNeighbors(reduction = "harmony", dims = 1:30) %>%
#     FindClusters()
#   p[[i]] <- rDimPlot(test, reduction = "umap", label = T, repel = T) +
#       coord_fixed() +
#       ggtitle(str_c("n.neighbors = ", (i * 10))) +
#       theme(legend.position = "none")
# }
# plot_grid(plotlist = p, ncol = 3)

# p <- list()
# for(i in 1:5) {
#   test <- RunUMAP(comb, reduction = "harmony", dims = 1:30, 
#     n.epochs = (i * 100))
#   test <- test %>%
#     FindNeighbors(reduction = "harmony", dims = 1:30) %>%
#     FindClusters()
#   p[[i]] <- rDimPlot(test, reduction = "umap", label = T, repel = T) +
#     coord_fixed() +
#     ggtitle(str_c("n.epochs = ", (i * 100))) +
#     theme(legend.position = "none")
# }
# plot_grid(plotlist = p, ncol = 3)

# p <- list()
# for(i in 1:5) {
#   test <- RunUMAP(comb, reduction = "harmony", dims = 1:30, 
#     min.dist = (.00045 * 4 ^ i))
#   test <- test %>%
#     FindNeighbors(reduction = "harmony", dims = 1:30) %>%
#     FindClusters()
#   p[[i]] <- rDimPlot(test, reduction = "umap", label = T, repel = T) +
#     coord_fixed() +
#     ggtitle(str_c("min.dist = ", (.00045 * 4 ^ i))) +
#     theme(legend.position = "none")
# }
# plot_grid(plotlist = p, ncol = 3)

# p <- list()
# for(i in 1:5) {
#   test <- RunUMAP(comb, reduction = "harmony", dims = 1:30, 
#     local.connectivity = (2 ^ i))
#   test <- test %>%
#     FindNeighbors(reduction = "harmony", dims = 1:30) %>%
#     FindClusters()
#   p[[i]] <- rDimPlot(test, reduction = "umap", label = T, repel = T) +
#     coord_fixed() +
#     ggtitle(str_c("local.connectivity = ", (2 ^ i))) +
#     theme(legend.position = "none")
# }
# plot_grid(plotlist = p, ncol = 3)
```

# Evaluate for cell cycle

```{r}
comb <- kill_cc(comb)
```

# Begin cell type annotation

Begin the process of identifying the cell types and annotating the samples. We will first
need to identify the tumor cells and separate them away from the stromal cells so that we
can focus in on the intratumoral heterogeneity.

First, we will use some standard assays to look for canonical markers of osteosarcoma cells.

```{r}
feats <- c("COL1A1", "COL1A2", "SATB2")

for(f in feats) {
  p <- rFeaturePlot(comb, f, features = f)
  print(p)
}
```

Next, we will look at the markers that were used in the manuscript that reported the
GSE152048 dataset. I'm not sure that these are the ideal markers, but they are somewhat
useful, and this allows comparison to the published record.

```{r, fig.height = 8, fig.width = 8}
ms <- list(
  Osteoblastic = c("RUNX2", "COL1A1", "CDH11", "IBSP"),
  Chondroblastic = c("SOX9", "ACAN", "PTH1R"),
  Osteoclast = c("ACP5", "CTSK", "MMP9"),
  Myeloid = c("CD74", "CD14", "FCGR3A"),
  TCell = c("CD3E", "IL7R", "CD8A", "CD4", "NKG7"),
  NKCell = c("NKG7", "GNLY"),
  NKTCell = c("NKG7", "GNLY", "CD3E"),
  DCCell = c("CD1C", "FCER1A", "CLEC9A", "CCR7", "CD14", "CD163"),
  Fibroblast = c("DCN", "COL1A1"),
  Pericyte = c("RGS5", "ACTA2"),
  MSC = c("MME", "THY1", "CXCL12", "SFRP2"),
  Endothelial = c("PECAM1", "VWF"),
  Myoblast = c("MYL1", "MYLPF"),
  BCell = c("MS4A1", "CD19", "JCHAIN")
)

g <- list()
for(f in names(ms)) {
  comb <- AddModuleScore(comb, ms[[f]], name = f)
  g[[f]] <- rFeaturePlot(comb, f, features = str_c(f, "1"))
}

plot_grid(plotlist = g, labels = LETTERS[1:length(g)], ncol = 4, nrow = 4)
```

Focus in on a module that defines the tumor cells so that we can isolate them.
Given the purpose in creating an osteosarcoma signature, we will use an ROC
statistic to create the DEG list.

```{r}
if (!file.exists("selection.rds")) {
  selection <- CellSelector(p)
  saveRDS(selection, "selection.rds")
}
selection <- readRDS("selection.rds")
tumor <- subset(comb, cells=selection)

Idents(comb) <- comb$seurat_clusters
Idents(comb, cells = selection) <- "Tumor"

rDimPlot(comb, "Isolated (likely) tumor cells")

tmarks_roc <- FindMarkers(comb, ident.1 = "Tumor",
  test.use = "roc")
tmarks_roc_labs <- tmarks_roc[
  tmarks_roc$power > .75 &
  abs(tmarks_roc$avg_log2FC) > 2.2, ]

tmarks_roc_labs$gene <- rownames(tmarks_roc_labs)
ggplot(tmarks_roc, aes(avg_log2FC, power)) +
  geom_point() +
  geom_label_repel(data = tmarks_roc_labs,
    aes(label = gene), max.overlaps = 20) +
  ggtitle("Genes that identify tumor cells")

os_sig <- rownames(tmarks_roc_labs[
  tmarks_roc_labs$avg_log2FC > 0, ])
comb <- AddModuleScore(comb, os_sig, name = "os_score")
FeaturePlot(comb, "OS Signature Score", features = "os_score1",
  min.cutoff = 1, max.cutoff = 5)
```

After several different criteria strict vs loose for defining the genes
that should comprise the osteosarcoma signature, it appears that the simplest
gene list based off of the strictest power/log2FC criteria performs the best.

# Isolate and subcluster the tumor cells

```{r, fig.width = 8, fig.width = 8}
# Normalize and scale tumor dataset
tumor <- tumor %>%
  NormalizeData() %>%
  FindVariableFeatures() %>%
  ScaleData() %>%
  RunPCA(verbose = F)

# Run batch-correction/integration using harmony
tumor <- RunHarmony(tumor, group.by.vars = "src")
tumor <- tumor %>%
  RunUMAP(reduction = "harmony", dims = 1:30) %>%
  FindNeighbors(reduction = "harmony", dims = 1:30) %>%
  FindClusters(resolution = 0.1)

# *** Need to optimize cluster selection with silhouette scoring***

rDimPlot(tumor, "Subclustered tumor cells")

rDimPlot(tumor, "Subclustered tumor cells", split.by = "src", ncol = 4)

tumor <- kill_cc(tumor)
rDimPlot(tumor, "Sublustered tumor cells - cell cycle", group.by = "Phase")
```

# Generate gene set lists that identify each tumor cell cluster

NOTE: Since this is a sub-clustering of cells that are highly 
related, it would be especially appropriate here to validate our
sub-clustering with silhouette scoring or similar.

```{r}
Idents(tumor) <- tumor$seurat_clusters

tumor_marks <- FindAllMarkers(tumor)
xlsx::write.xlsx(tumor_marks, "tumor_marks.xlsx")
tumor_marks <- xlsx::read.xlsx("tumor_marks.xlsx", 1)

tumor_marks <- as.tibble(
  tumor_marks[order(-tumor_marks$avg_log2FC),])
num_genes <- 20

for(i in levels(Idents(tumor))) {
  print(paste(
    "Top", num_genes, "UPREGULATED genes in cluster", i
  ))
  print(head(
    tumor_marks[tumor_marks$cluster == i,], n = num_genes
  ))
  print(paste(
    "Top", num_genes, "DOWNREGULATED genes in cluster", i
  ))
  print(tail(
    tumor_marks[tumor_marks$cluster == i,], n = num_genes
  ))
}
```

# From the cluster-marker gene lists, identify up- and down-regulated pathways

```{r}
dbs <- c(
  "MSigDB_Hallmark_2020",
  "KEGG_2021_Human",
  "Reactome_2016"
)

enriched_up <- list()
enriched_down <- list()
for(i in levels(Idents(tumor))) {
  up <- tumor_marks$gene[tumor_marks$cluster == i & tumor_marks$avg_log2FC > 0.7]
  down <- tumor_marks$gene[tumor_marks$cluster == i & tumor_marks$avg_log2FC < 0.7]
  enriched_up[[paste("Cluster", i)]] <- enrichr(up, dbs)
  enriched_down[[paste("Cluster", i)]] <- enrichr(down, dbs)
}
```